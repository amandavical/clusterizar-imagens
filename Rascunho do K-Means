//struct pgm {
//    int tipo; (Tipo da imagem);
//    int c; (Largura);
//    int r; (Altura);
//    int mv; (Intensidade máxima dos pixels);
//    unsigned char *pData; (Vetor dos pixels);
//};

#define K 4

int *alocarMemoria(int n) {
    int *p = NULL;

    if (!(p = (int*) malloc(n * sizeof(int)))) {
        puts("Memória insuficiente");
        exit(1);
    }

    return p;
}

void histogramaPixels(struct pgm *pio, int *histograma) {
    // *pio é o ponteiro que representa as informações da imagem;
    // O laço de repetição serve para analisar todos os pixels da imagem;
    for (int i = 0; i < pio->r * pio->c; i++) {
        histograma[pio -> pData[i]]++; // Incrementa toda vez que um valor de intensidade de pixel aparece;
    }
}

void selecionarCentroides(int k, int *histograma, unsigned char *centroides) {
    // 'k' representa a quantidade de centroides;
    int soma = 0;

    for (int i = 0; i < k; i++) {
        int intervalo = (i + 1) * (256 / k); // Realiza a divisão dos centroides através de intervalos distintos de intensidade;

        while (intervalo > soma) {
            soma += histograma[i];
            i++;

            // A variável 'soma' recebe o valor do histograma;
            // A incrementação do 'i' é para garantir a análise de todas as intensidades abordadas pelo histograma;
            // O laço de repetição continua até que 'soma' atinja o valor do 'intervalo';
        }
    }

    centroides[i] = i; // A intensidade de maior frequência torna-se o centroide;
}

int distanciaAbsoluta(int a, int b) {
    return abs(a - b);
}

void kMeans(struct PGM *pio, int k, int mx) {
    // 'k' representa os "clusters";
    // 'mx' é o limite de iterações;

    int *clusters;
    unsigned char *centroides;
    unsigned char *centroides2; // Novo centroide;
    int *qtdPixels;

    clusters = alocarMemoria(pio -> r);
    centroides = alocarMemoria(k);
    centroides2 = alocarMemoria(k);
    qtdPixels = alocarMemoria(k);

    int histograma[256] = {0};
    
    histogramaPixels(pio, histograma);
    selecionarCentroides(k, histograma, centroides);

    int estabilizado = 0;

    do {
        for (int h = 0; h < mx; h++) {
            int mudança = 0;

            for (int i = 0; i < pio->r * pio->c; i++) {
                // Analisa todos os pixels da imagem;
                int distanciaMinima;
                distanciaMinima = distanciaAbsoluta(pio->pData[i] - centroides[0]);
                // Cálculo da distância entre cada intensidade e o centroide inicial;
                clusters[i] = 0; // Todos os pixels vão para o cluster inicial;

                for (int j = 0; j < k; j++) {
                    // Percorre os outros centroides;
                    int distancia = distanciaAbsoluta(pio->pData[i] - centroides[j]);
                    // Cálculo da distância entre cada intensidade e os outros centroides;
                    if (distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        clusters[i] = j;
                        // Se a distância obtida for menor do que a mínima, então o centroide 'j' está mais próximo do pixel;
                        // Caso isso aconteça, o pixel é agrupado em outro cluster;
                    }
                }
            }

            for (int i = 0; i < k; i++) {
                // Recálculo dos centroides;
                centroides2[i] = 0; // O novo centroide é zerado;
                qtdPixels[i] = 0; // Número de pixels em um determinado cluster 'i';
            }

            for (int i = 0; i < pio->r * pio->c; i++) {
                centroides2[clusters[i]] += pio->pData[i];
                qtdPixels[clusters[i]]++;
                // O novo centroide é incrementado no valor da intensidade de um pixel 'i', pertencente a um determinado cluster;
                // Isso servirá para fazer o cálculo de uma média, que ajudará no processo de atualizar o centroide;
            }

            for (int i = 0; i < k; i++) {
                if (qtdPixels[i] > 0) {
                    centroides2[i] = centroides2[i] / qtdPixels[i];
                    // É realizado o cálculo da média das intensidades de cada cluster;
                    // Os centroides de cada cluster são assim recalculados;
                }
            }

            for (int i = 0; i < k; i++) {
                if (centroides[i] != centroides2[i]) {
                    mudança = 1;
                }
                centroides[i] = centroides2[i];
                // Os centroides são atualizados;
            }

            if (!mudança) {
                estabilizado = 1;
                break;
            }
        }
    } while (estabilizado == 0);

    free(clusters);
    free(centroides);
    free(centroides2);
    free(qtdPixels);
}
